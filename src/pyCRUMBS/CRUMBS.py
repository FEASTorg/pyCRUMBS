import struct
import logging
import ctypes
from pathlib import Path
from typing import Optional

from smbus2 import SMBus, i2c_msg

from .CRUMBSMessage import CRUMBSMessage, CRUMBS_MESSAGE_SIZE, CRUMBS_DATA_LENGTH

# Logging setup
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("pyCRUMBS")

# Load shared CRC-8 library generated by pycrc (compiled from crc8_nibble.c)
_lib_path = Path(__file__).parent / "libcrc8.so"
if _lib_path.exists():
    _crc = ctypes.CDLL(str(_lib_path))
    _crc.crc_calculate.argtypes = [ctypes.POINTER(ctypes.c_uint8), ctypes.c_size_t]
    _crc.crc_calculate.restype = ctypes.c_uint8
else:
    _crc = None
    logger.warning(
        "CRC library not found at %s. Falling back to Python implementation.",
        _lib_path,
    )


CRC_POLY = 0x07


def _crc_fallback(data: bytes) -> int:
    crc = 0x00
    for byte in data:
        crc ^= byte
        for _ in range(8):
            if crc & 0x80:
                crc = ((crc << 1) & 0xFF) ^ CRC_POLY
            else:
                crc = (crc << 1) & 0xFF
    return crc & 0xFF


def _compute_crc(data: bytes) -> int:
    if not data:
        return 0
    if _crc is not None:
        buf = (ctypes.c_uint8 * len(data)).from_buffer_copy(data)
        return int(_crc.crc_calculate(buf, len(data))) & 0xFF
    return _crc_fallback(data)


class CRUMBS:
    """pyCRUMBS implementation for Raspberry Pi (I2C master)."""

    def __init__(self, bus_number: int = 1) -> None:
        self.bus_number = bus_number
        self.bus: Optional[SMBus] = None

    def begin(self) -> None:
        self.bus = SMBus(self.bus_number)
        logger.info("I2C bus %d opened as master.", self.bus_number)

    # ------------------- Encoding / Decoding -------------------
    def encode_message(self, msg: CRUMBSMessage) -> bytes:
        if len(msg.data) != CRUMBS_DATA_LENGTH:
            logger.error(
                "Encoding failed: data length %d does not match CRUMBS_DATA_LENGTH=%d",
                len(msg.data),
                CRUMBS_DATA_LENGTH,
            )
            return bytes()

        try:
            payload = struct.pack("<BB7f", msg.typeID, msg.commandType, *msg.data)
            crc = _compute_crc(payload)
            encoded = payload + struct.pack("<B", crc)
            logger.debug("Encoded message CRC=%02X: %s", crc, encoded.hex())
            return encoded
        except Exception as e:
            logger.error("Encoding failed: %s", e)
            return bytes()

    def decode_message(self, buffer: bytes) -> CRUMBSMessage | None:
        if len(buffer) < CRUMBS_MESSAGE_SIZE:
            logger.error("Buffer too short for CRUMBS frame.")
            return None
        try:
            payload = buffer[: CRUMBS_MESSAGE_SIZE - 1]
            recv_crc = buffer[CRUMBS_MESSAGE_SIZE - 1]
            calc_crc = _compute_crc(payload)
            if calc_crc != recv_crc:
                logger.error("CRC mismatch: recv=%02X calc=%02X", recv_crc, calc_crc)
                return None
            typeID, cmd, *floats = struct.unpack("<BB7f", payload)
            return CRUMBSMessage(
                typeID=int(typeID),
                commandType=int(cmd),
                data=list(floats),
                crc8=int(recv_crc),
            )
        except Exception as e:
            logger.error("Decoding failed: %s", e)
            return None

    # ------------------- I2C Operations -------------------
    def send_message(self, message: CRUMBSMessage, addr: int) -> bool:
        encoded = self.encode_message(message)
        if len(encoded) != CRUMBS_MESSAGE_SIZE:
            logger.error("Invalid encoded length: %d", len(encoded))
            return False
        try:
            if self.bus is None:
                logger.error("I2C bus not open.")
                return False
            write = i2c_msg.write(addr, list(encoded))
            self.bus.i2c_rdwr(write)
            logger.info("Sent %d bytes to 0x%02X", len(encoded), addr)
            return True
        except Exception as e:
            logger.error("Send failed: %s", e)
            return False

    def request_message(self, addr: int) -> CRUMBSMessage | None:
        try:
            if self.bus is None:
                logger.error("I2C bus not open.")
                return None
            read = i2c_msg.read(addr, CRUMBS_MESSAGE_SIZE)
            self.bus.i2c_rdwr(read)
            buf = bytes(read)
            return self.decode_message(buf)
        except Exception as e:
            logger.error("Request failed: %s", e)
            return None

    def close(self) -> None:
        if self.bus:
            self.bus.close()
            logger.info("I2C bus closed.")
            self.bus = None
